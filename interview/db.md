## 数据库
### 三范式
第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。


### ACID
原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。

一致性是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。保证数据库一致性是指当事务完成时，必须使所有数据都具有一致的状态。在关系型数据库中，所有的规则必须应用到事务的修改上，以便维护所有数据的完整性。


隔离性多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。


### 锁
类型：排他锁、共享锁

范围或粒度：行、表、页锁
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

并发控制机制：分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，乐观锁其实并不是一种真实存在的锁，我们会在文章后面的部分中具体介绍；最后就是多版本并发控制（MVCC）了，与前两者对立的命名不同，MVCC 可以与前两者中的任意一种机制结合使用，以提高数据库的读性能。

两阶段锁：在增长阶段，一个事务可以获得锁但是不能释放锁；而在缩减阶段事务只可以释放锁，并不能获得新的锁

死锁解决方法：
- 预防
- 抢占
- 死锁检测

### index
- 主键：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。
- 唯一索引：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以在创建表的时候指定，也可以修改表结构
- 普通index
- 组合索引，即一个索引包含多个列
- 全文索引：利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。
- 聚簇索引


### 隔离等级
- read uncommitted:一个事务可以读取了其他事务没有提交的内容，称为脏读
- read committed: 一个事务只能看见已经提交事务所做的改变。可能造成重复读取不一致的现象（即不可重复读）：第一个事务读取了值，然后第二个事务更改并提交新值，此时如果第一个事务再读一次，就会发现两个数据不一致。只是大多数数据库的默认隔离级别。
- repetable read：可重读，即一个事务前后两次读取的数据结果是一致的。这是mysql的默认隔离级别。但是可能会出现幻读：幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
- Serializable 可串行化：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。


- 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

- 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

### b+ tree


### 其他
- https://juejin.im/post/5cb6c4ef51882532b70e6ff0
- 隔离等级 https://www.jianshu.com/p/8d735db9c2c0