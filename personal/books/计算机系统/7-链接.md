&#8195;&#8195;自从换了工作以后，学习、阅读的时间就相对减少了，日益觉得自己面目可憎了。

<p align="center">
<img src="../img/广州灯光节.jpeg" alt="广州灯光节" width="500"/>
</p>

&#8195;&#8195;链接是将各种代码和数据片段手机并组合成为一个单一文件的过程，这个文件可被加在到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载到内存执行时；甚至执行于运行时，也就是由应用程序来执行。在现代系统中，链接是由叫链接器的程序自动执行的。

&#8195;&#8195;为什么要了解连接器：
- 理解连接器将帮助你构建大型程序
- 理解链接器将帮助你避免一些危险的编程错误
- 理解连接器将帮助你理解语言的作用域规则是如何实现的
- 理解链接将是你利用共享库（或者链接库的工作原理）

下文的例子、内容使用c语言为例，其他语言也是大同小异。

## 编译器驱动程序
<p align="center">
<img src="../img/linking.png" alt="编译过程" width="350"/>
</p>

&#8195;&#8195;大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和连接器。

- 驱动程序首先运行C预处理器，它将c的源程序main.c翻译成一个ASCII码的中间文件main.i。命令如下：cpp main.c main.i
- 接下来运行c编译器，它将main.i翻译成一个ASCII汇编语言文件main.s。命令如下：cc1 main.i -Og -o main.s
- 然后运行汇编器as，它将main.s翻译成一个可重定位目标文件(文件内引用的外部变量、外部函数、外部库尚待链接器来定位加载)。命令如下：as -o main.o main.s
- 最后运行连接器ld，将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件。命令如下：ld -o main main.o sum.o

&#8195;&#8195;运行时，shell调用操作系统一个叫加载器（loader）的函数，来将可执行文件中的代码和数据复制到内存，然后将控制权转移到程序的开头。


## 静态链接
&#8195;&#8195;像linux LD程序这样静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输出的可重定位目标文件由各种不同的代码和数据节组成。

&#8195;&#8195;为了构造可执行文件，连接器必须完成以下两个主要任务：
- 符号解析：每个符号对应于一个函数、一个全局变量或者一个静态变量。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。（比如根据一个函数名跳转到其对应的代码位置）
- 重定位：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义和一个内存位置关联起来，从而重定位这些节。

## 目标文件
目标文件有三种形式：
- 可重定位目标文件：包含二进制代码和数据，其形式可以在编译时和其他可重定位目标文件合并起来，创建一个可执行目标文件
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。（java的动态加载的基本原理也类似如此）

&#8195;&#8195;编译器、汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。

## 可重定位目标文件
<p align="center">
<img src="../img/reloactable_target_file.png " alt="可重定位目标文件结构" width="200"/></p>

- ELF header开头的16个字节描述该文件的系统的字的大小和字节顺序。剩余部分包含帮助链接器语法分析和解析目标文件的信息，如ELF header 的大小、目标文件类型（可重定位/可执行/可共享）、机器类型（x86-64）、节头部表的文件偏移等。
- .text：已编译程序的机器代码
- .rodata：只读数据，比如printf语句中的格式串和开关语句的跳转表
- .data：已初始化的全局和静态C变量
- .bss：未初始化的全局和静态C变量，以及所有被初始化未0的全局和静态变量（为何命名为bss也是一段有趣的历史）
- .symtab: 一个符号表，它存放了程序中定义和引用的函数和全局变量的信息
- .rel.txt: 一个.txext节中位置的列表，当连接器把这个目标文件和其他文件组合时，需要修改这些位置。即函数表
- .rel.data：被模块引用或定义的所有全局变量的重定位信息。即外部数据表
- .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义、程序中定义和引用的全局变量表、原始的c源文件。只有在编译时使用 -g 选项才会得到这张表
- .line：程序中的行号和.text节中机器指令之间的映射，只有以-g选项调用编译器驱动程序才会得到这张表（程序运行时可以打印代码行号也是基于这个表）
- .strtab：一个字符串表，其内容包括.symtab和.debug中的符号表


## 符号和符号表
&#8195;&#8195;每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：
- 由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量
- 由其他模块定义并被模块m引用的全局符号。这些符号被成为外部符号，对应于在其他模块中定义非静态的C函数和全局变量
- 只被模块m定义和引用的局部符号。对应于带static属性的C函数和全局变量。

不包含本地非静态程序变量的任何符号。

符号表是由汇编器构造的。表中的每个项代表一个符号，每个项的结构如下
```c
typedef struct {
    int name;       // 字符串表.strtab中的字节偏移
    char type:4     // 表示符号是数据还是函数
        binding:4;  // 表示符号是本地还是全局
    char reserved;
    short section; // 该符号被分配到目标文件的哪个字节，不同的值对应 .rodata/.bss等节
    long value;    // 符号的地址。对于可重定位模块来说，value是距定义目标的节的起始位置偏移
    long size;     // 目标的大小，单位字节
}
```

## 符号解析
&#8195;&#8195;链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。（也就是根据引用，从符号表找到符号具体定义的位置）。

&#8195;&#8195;对于本模块内的变量，符号解析是非常简单明了的。但是对于全局符号的引用解析，当编译器没法在当前模块找到其定义时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并将它交给链接器处理。如果链接器在它的任何输入模块都找不到这个被引用符号的定义，就会报错。如：
```
undefined reference to $your_variable/func_mame
```

### 关联/联想
&#8195;&#8195;c++、java等语言支持方法重载，这些方法在源代码中都有着相同的名字，却有这不同的参数，那么链接器是如何区别这些重载方法的？原因是编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这个过程叫“重整”，而相反的过程叫“恢复”。类Foo的bar(int, long)方法就被编码为“bar__3Fooil”。其中的“3”是类的名字长度，“i”和“l”表示参数类型分别为int和long。（再思考一下，如果参数不是基本类型，那么编码会是什么？可能是struct名）

### 多重定义的全局符号的解析
&#8195;&#8195;链接器输入的模块中，有一些符号是局部的，有些是全局的（及其他模块可见）。如果多个模块定义同名的全局符号，会发生什么？下面是linux编译系统采用的方法。

&#8195;&#8195;在编译时，编译器向汇编器输出每个全局符号（强符号或者弱符号），并把强弱信息编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

根据强弱符号的定义，linux有如下规则处理多重定义的符号名：
- 规则1: 不允许有多个同名的强符号。违反则输出“multiple definition of xxxx”
- 规则2: 如果有一个强符号和多个弱符号同名，则选择强符号。
- 规则3: 如果多个弱符号同名，则从这些弱符号任意选择一个

规则二有如下例子：
```c
// foo3.c
int x = 10; // 已初始化的全局变量是强符号
int main() {
    f();
    print(x); // 运行输出：1234
    return 0;
}

// bar3.c
int x; // 未初始化的全局变量是弱符号
void f() {
    x = 1234; // 优先选取强符号
}

// 运行输出：1234
gcc -o des_file foo3.c bar3.c
```

### 静态库链接
&#8195;&#8195;编译系统提供了一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库，它可以作为链接器的输入。当链接器构造一个输出的可执行文件，它只复制静态库里面被应用程序引用的目标模块。

如果不使用静态库，另一种复用代码的方法就是将所有的公用库都放在一个单独的可重定位目标模块（如govendor，js node_modules等），然而这有一些缺点。如果多个可执行文件都用到了同一个代码库（比如c标准库函数），那么：
- 每个执行文件都包含一份标准函数集合的完全副本，对磁盘空间造成很大的浪费
- 每个运行中的程序都将它自己的这些函数副本放到内存里面，造成内存的极度浪费
- 对标准库的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，操作耗时，且造成函数开发和维护更为复杂

在含静态库的编译系统中，相关的函数编译成独立的目标模块（比如标准输出模块、网络io模块），然后封装成一个单独静态库文件。然后应用程序在命令行上指定需要使用的静态库文件来使用这些在库中定义的函数（当然还是没法解决上述第二个缺点）。如：
```sh
gcc main.c /usr/lib/libm.a /usr/lib/libc.a
```

在linux系统中，静态库以一种被称为存档（archive）的特殊文件（即a文件）格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件组合。

a文件的创建方法如下：
```sh
# 将两个c文件编译成一个静态库
# step 1: 将源文件编译成o文件
gcc -c addvec.c multvec.c
# 将上一步产生的两个o文件封装成一个存档文件libvector.a
ar rcs libvector.a addvec.o multvec.o
```

后续，如果某个程序main.c引用到addvec.c，那么可以如下编译:
```
gcc -c main.c
gcc -static -o prog2c main2.o -L. -lvector
```
- static: 告诉编译器，链接器应该构建一个完全链接的可执行的目标文件，它可以被加载到内存并运行，在加载时无需更进一步的链接
- lvector是libvector.a的缩写
- -L. 告诉链接器在当前目录想寻找lvector.a
- 该命令会只将用到的addvec.c编译到目标文件，而将multvec排除在外
 


## 可执行目标文件
<p align="center">
<img src="../img/executable.png " alt="可执行目标文件" width="400"/></p>

&#8195;&#8195;从上图可见，可执行目标文件的结构和可重定位目标文件的结构十分相似（可执行目标文件就是对可重定位目标文件解析其引用后链接得到到）。同名的段的作用也是一样的，因此此处不再赘述。

- .init节定义了一个小函数，叫做init，程序初始化代码的时候会调用它。

### 加载可执行目标文件
如果要运行可执行目标文件prog，可以在命令行输入它的名字：
```sh
./prog
```

那么按了确定之后，操作系统会发生什么？程序是如何加载、初始化、运行的？（面试送命题）

&#8195;&#8195;因为prog不是一个内置的shell命令，所以shell会认为prog是一个可执行目标文件，通过调用某个驻留在存储器中的称为加载器（loader）的操作系统代码来运行它。任何linux程序都可以通过调用execve函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令和入口点（某个特定的虚拟地址，不同操纵系统不一样）来运行该程序。这个将程序复制到内存并运行的过程叫做加载。

<p align="center">
<img src="../img/proc_memory_struct.png " alt="linux x86-64进程运行时内存映像" width="250"/></p>

&#8195;&#8195;每个linux程序都有一个运行时的内存映像（即进程的内存结构）。在linux x86-64系统中，代码段总是从地址0x400000出开始的，后面是数据段。运行时堆在数据段之后，通过调用malloc库从上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法地址（2^48-1）开始，向较小内存地址方向增长。栈上的区域，从2^48开始，是为内核中的代码和数据保留的，所谓内核就是操作系统驻留在内存中的部分。（为了简介，上图中堆、数据、代码段画的彼此相连，并把栈顶放在最大的合法地址。实际上，代码段和数据段之间是有间隙的）

&#8195;&#8195;当加载器运行是，它创建类似于上图的内存映像。在程序头部表的引导下，加载器将可执行目标文件的片（chunk）复制到代码段和数据段。接下来，加载器调跳转到程序的入口点，也就是_start函数的地址。这个函数是在系统目标文件ctrl.o中定义的，对所有的c程序都是一样的。_start函数调用系统启动函数__libc_start_main，该函数定义在libc.so中。它初始化执行环境，调用用户层的main函数，处理main函数的返回值，并且在需要的时候把控制权交还给内核。
```
execve -> loader -> _start函数 -> _libc_start_main -> main()
```

&#8195;&#8195;上面着重于描述加载的过程。下面是关于加载实际是如何工作的一个概述：linux系统的每个程序都运行在一个进程上下文中，它是父进程的一个复制（fork）。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆、栈段。新的栈和堆段被初始化为零。通过将虚拟内存地址空间中的页映射到可执行文件的页大小的片（chunk），新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。除了一些头部信息，在加载过成中没有任何从磁盘到内存的数据复制，直到cpu引用一个被映射的虚拟页才会被复制，此时，操作系统利用的页面调度机制将页面从磁盘传送到内存。（面试这么回答基本就可以了）

## 动态链接共享库
&#8195;&#8195;静态库有个缺点就是：如果多个程序都引用同一个目标模块（如标准库的printf函数），那么这些函数会被复制到每个运行程序的文本段中，造成内存资源的浪费。

&#8195;&#8195;针对这个缺点，提出动态共享库（如windows的ddl，在linux中则是.so文件等）。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个内存中的程序链接起来，这个过程称为动态链接，是由一个叫做动态链接器（dynamic linker）的程序来执行的。

&#8195;&#8195;基本思路就是，当创建可执行目标文件，静态执行一些链接，然后在程序加载时，动态完成链接。

&#8195;&#8195;动态链接器本身就是一个共享目标，加载器不会想它通常所做的那样将控制交给应用，而是加载和运行这个动态链接器，然后，动态链接器重定位来完成链接任务。

&#8195;&#8195;联想，java的动态加载：jiava定义了一个标准调用规则，叫做jiava本地接口（java native interface，JNI），它允许java程序调用“本地的”c和c++函数。JNI的基本思想就是将本地C函数（如foo）编译到一个共享库（foo.so）。当一个正在运行的jiava程序试图调用函数foo，java解析器利用dlopen接口（或者类似的接口）动态链接和加载foo.so，然后再调用foo。

## 其他
其他概念就不说了
- 库打桩机制
  